AI BUG PREDICTOR - SYSTEM ARCHITECTURE
======================================

1. OVERVIEW
-----------
The AI Bug Predictor is a full-stack application that combines:
- Frontend (HTML/CSS/JavaScript)
- Backend (Python FastAPI)
- Machine Learning (Scikit-learn)
- AI Services (Gemini & DeepSeek APIs)

2. ARCHITECTURE DIAGRAM
-----------------------

┌─────────────────────────────────────────────────────────────┐
│                    FRONTEND (Browser)                        │
│  ┌────────────┐  ┌──────────────┐  ┌──────────────────┐    │
│  │index.html  │  │student.html  │  │developer.html    │    │
│  │(Landing)   │  │(Learning)    │  │(Code Analysis)   │    │
│  └────────────┘  └──────────────┘  └──────────────────┘    │
│          │              │                       │           │
│  ┌───────┴───────┐┌─────┴──────┐      ┌────────┴────────┐  │
│  │Three.js       ││Chart.js    │      │Custom JS        │  │
│  │(3D Background)││(Visualization)    │(Logic)          │  │
│  └───────────────┘└────────────┘      └─────────────────┘  │
└───────────────────────────┬─────────────────────────────────┘
                            │ HTTP/HTTPS (REST API)
┌───────────────────────────┴─────────────────────────────────┐
│                    BACKEND (FastAPI)                        │
│  ┌──────────────────────────────────────────────────────┐  │
│  │                     main.py                          │  │
│  │                 (API Endpoints)                      │  │
│  └─────────┬──────────────────────────────┬─────────────┘  │
│            │                              │                │
│  ┌─────────┴─────────┐        ┌──────────┴──────────┐     │
│  │   ml_service.py   │        │    ai_service.py    │     │
│  │  (ML Predictions) │        │  (AI Explanations)  │     │
│  └─────────┬─────────┘        └──────────┬──────────┘     │
│            │                              │                │
│    ┌───────┴───────┐              ┌──────┴──────┐         │
│    │  model.pkl    │              │  Gemini API │         │
│    │ (Trained ML)  │              │ DeepSeek API│         │
│    └───────────────┘              └─────────────┘         │
└─────────────────────────────────────────────────────────────┘

3. COMPONENT DETAILS
-------------------

3.1 FRONTEND COMPONENTS:
- index.html: Landing page with mode selection
- student.html: Interactive learning interface with chatbot
- developer.html: Code analysis interface with visualizations
- CSS/Styles: Responsive design with dark theme and neon effects
- JavaScript: Interactive features, API calls, animations

3.2 BACKEND COMPONENTS:
- main.py: FastAPI application with endpoints:
  * POST /predict-bug: ML-based bug prediction
  * POST /student-chat: AI explanations for students
  * POST /developer-fix: AI-powered code fixes
  
- ml_service.py: Machine Learning service
  * Loads trained model (model.pkl)
  * Extracts features from code
  * Predicts bug probability
  * Classifies severity levels
  
- ai_service.py: AI integration service
  * Gemini API for educational explanations
  * DeepSeek API for code fixes
  * Fallback responses when APIs unavailable

- schemas.py: Pydantic models for validation
- utils.py: Utility functions for code analysis

3.3 MACHINE LEARNING:
- bug_prediction.ipynb: Jupyter notebook for model development
- train_model.py: Script to train and save model
- model.pkl: Trained logistic regression model
- dataset/: Contains training data

4. DATA FLOW
-----------

4.1 STUDENT MODE FLOW:
1. User asks question or uploads code in student.html
2. Frontend sends POST to /student-chat
3. Backend processes with ai_service.py
4. Gemini API generates educational explanation
5. Response displayed with typing animation

4.2 DEVELOPER MODE FLOW:
1. User submits code in developer.html
2. Frontend sends POST to /predict-bug
3. ml_service.py extracts features and predicts bugs
4. Results displayed with charts and metrics
5. User can request AI fix via /developer-fix
6. DeepSeek API generates fixed code

5. ML PIPELINE
--------------

5.1 TRAINING PHASE:
1. Load dataset (50k samples)
2. Feature extraction and engineering
3. Train Logistic Regression model
4. Evaluate with accuracy, ROC-AUC
5. Save model as model.pkl

5.2 PREDICTION PHASE:
1. Extract features from input code
2. Scale features using saved scaler
3. Predict probability using saved model
4. Map probability to severity levels:
   - > 0.8: Critical
   - 0.6-0.8: High
   - 0.4-0.6: Medium
   - < 0.4: Low

6. AI INTEGRATION
----------------

6.1 GEMINI API (Google):
- Purpose: Educational explanations
- Input: Student questions + code context
- Output: Markdown-formatted explanations
- Features: Beginner-friendly, examples, tips

6.2 DEEPSEEK API:
- Purpose: Code analysis and fixes
- Input: Buggy code + issue description
- Output: Fixed code + explanation
- Features: Multi-language support, best practices

7. ERROR HANDLING
----------------

7.1 FALLBACK MECHANISMS:
- ML Service: Fallback model when trained model unavailable
- AI Service: Pre-generated responses when APIs fail
- Frontend: Local analysis when backend unavailable

7.2 VALIDATION:
- Input validation with Pydantic schemas
- Code syntax validation
- API response validation

8. SECURITY CONSIDERATIONS
-------------------------

8.1 IMPLEMENTED:
- CORS configuration
- Input sanitization
- API key management (environment variables)
- Rate limiting (conceptual)

8.2 RECOMMENDED:
- Authentication for production
- HTTPS enforcement
- API key rotation
- Request logging

9. SCALABILITY
--------------

9.1 CURRENT:
- Stateless backend
- Model caching
- Async API calls

9.2 POTENTIAL IMPROVEMENTS:
- Load balancing
- Model versioning
- Response caching
- Database for history

10. DEPLOYMENT
-------------

10.1 LOCAL DEVELOPMENT:
- Python virtual environment
- Frontend: Open HTML files directly
- Backend: uvicorn main:app --reload

10.2 PRODUCTION READY:
- Docker containerization
- Nginx reverse proxy
- Process manager (Gunicorn)
- Environment configuration

11. MONITORING
-------------

11.1 BUILT-IN:
- Health check endpoint (/health)
- Request counting
- Error logging

11.2 RECOMMENDED:
- Performance metrics
- Model drift detection
- User analytics
- Error tracking

12. FUTURE ENHANCEMENTS
----------------------

12.1 ML IMPROVEMENTS:
- More sophisticated models (XGBoost, Neural Networks)
- Real-time model retraining
- Feature importance visualization
- Multi-language support

12.2 AI ENHANCEMENTS:
- Multiple AI provider support
- Cost optimization
- Response caching
- Quality scoring

12.3 FRONTEND ENHANCEMENTS:
- Real-time collaboration
- Code version comparison
- Team features
- Advanced visualizations

13. HACKATHON RELEVANCE
----------------------

13.1 INNOVATION:
- Combines ML and AI for practical problem
- Educational focus for students
- Professional tool for developers
- Modern tech stack

13.2 COMPLETENESS:
- End-to-end working solution
- Production-ready architecture
- Comprehensive documentation
- Demo-ready interface

13.3 IMPACT:
- Helps prevent software bugs
- Educates new programmers
- Saves developer time
- Improves code quality